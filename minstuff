
function getPTheorm(xval, yval) {
	var sumOfSqr = (xval**2)+(yval**2);
	return Math.sqrt(sumOfSqr);
}

function getSquaredDistanceOfPoint(xval, yval) {
	var ret = getPTheorm(xval, yval)
	return ret*ret
}

function getTotalDiffSquaredOfPoints(points) {	
	total = 0
	for point in points:
		total += getSquaredDistanceOfPoint(point)
	return total
}

function getTotalDiffSquaredOfPoints(points) {
	total = 0
	for point in points:
		total += getSquaredDistanceOfPoint(point)
	return total
}

function scaleInX(xval, normX) {
	xval = xval*normX
	return ret
}

function rotatePoint(degrees, xval, yval) {
	rads = math.radians(degrees)
	sinT = math.sin(rads)
	cosT = math.cos(rads)
	rotMat = np.mat([[cosT,sinT],[-sinT,cosT]])
	pointMat = np.mat([[xval], [yval]])
	resMat = rotMat*pointMat
	resXVal = resMat.xval
	resYVal = resMat.yval
	return [resXVal, resYVal]
}

function applyTransformToPoint(tetha, normX, point) {
	ret = point
	ret = rotatePoint( tetha, ret)
	
	ret = scaleInX(ret, normX)
	
	ret = rotatePoint(-tetha, ret)
	return ret
}

function applyTransformToAllPoints(tetha, normX, normY, points) {
	ret = []
	for point in points:
		newPoint = point
		newPoint = applyTransformToPoint(tetha, normX, newPoint)
		newPoint = applyTransformToPoint(tetha+90, normY, newPoint)
		ret.append(newPoint)
	
	return ret
}

function applyTransformToAllPointsNormd(tetha, normS, points) {
	normX, normY = turnXIntoSqrtX(normS)
	return applyTransformToAllPoints(tetha, normX, normY, points)
}


function scaleInDirection(shape, angle, scale) {	
	finalShape = applyTransformToAllPointsNormd(angle, scale, shape)
	ret = []
	for point in finalShape:
		ret.append( (point[0], point[1]) )
	return ret
}

function calcDiffSquaredOfEveryPoint(shape, angle, scale) {
	if(scale < 0):
		scale = scale*-1
	
	newShape = scaleInDirection(shape, angle, scale)
	totalDiff = getTotalDiffSquaredOfPoints(newShape)
	totalDiff += getTotalDiffSquaredOfAngles(newShape)
	return totalDiff
}

//now min the function 

global_shape = []
function f(variables, params) {
	shape = global_shape
	angle, scale = variables
	return calcDiffSquaredOfEveryPoint(shape, angle, scale)
}

function frange(x, y, jump) {
  while x < y:
    yield x
    x += jump
}

function getAllRotationAndScaleValuesForShape(shape) {
	ret = []
	for i in frange(0, 360, .1):
		for j in frange(1,7, .1):
			val = calcDiffSquaredOfEveryPoint(shape, i, j)
			ret.append([val,['scaler',j],['angle', i]])

	return ret
}

function getAllRotationAndScaleValuesForShape_withOrder(shape) {
	vals = getAllRotationAndScaleValuesForShape(shape)
	vals.sort(key=lambda tup: tup[0])  # sorts in place
	return vals
}

########## public
function getValuesToNormaliseScale1(shape) {
	finalShape = BSO.centerShapeUsingPoint(shape, (0,0))
	vals = getAllRotationAndScaleValuesForShape_withOrder(finalShape)
	#for i in range(10):
	#	print vals[i]
	#return the local minimum
	return (vals[0][2][1], vals[0][1][1])
}

function getValuesToNormaliseScale2(shape, inputRange) {
	shape = BSO.centerShapeUsingPoint(shape, (0,0))
	bounds = [(low, high) for low, high in zip(inputRange[0], inputRange[1])]
	minimizer_kwargs = {"args": shape, "bounds": bounds}
	val = optimize.basinhopping(f, [1,1], minimizer_kwargs=minimizer_kwargs)
	scale = val['x'][1]
	if (scale < 0) {
		scale = scale*-1
	}
	return val['x'][0], scale 
}


function getValuesToNormaliseScale(shape, inputRange) {
	shape = BSO.centerShapeUsingPoint(shape, (0,0))
	bounds = inputRange
	
	global global_shape 
	global_shape = shape
	val = optimize.differential_evolution(f, bounds)
	
	#print val
	scale = val['x'][1]
	if (scale < 0) {
		scale = scale*-1
	}
	return val['x'][0], scale 
}

function getValuesToNormaliseScaleNoInputRange(shape) {
	rangeInput = [(0.,359.0), (1.,8.)]
	return getValuesToNormaliseScale(shape, rangeInput)
}

/*
##################################################################

############# Rotation

#################################################################
*/

function getCount(img) {
	countLeft = 0
	countRight = 0
	height, width = img.shape
	for (i in range(0, height)) {
		for (j in range(0, width)) {
			if j < (width/2):
				countLeft 	+= img[i,j]
			else:
				countRight 	+= img[i,j]
		}
	}
	return countLeft, countRight
}

function rotateImgBAndW(img, rotate) {
	rows,cols = img.shape
	return _rotateImg(img, rotate, rows, cols)
}

function rotateImg(img, rotate) {
	rows,cols,c = img.shape
	return _rotateImg(img, rotate, rows, cols)
}

function _rotateImg(img, rotate, rows, cols) {
	M = cv2.getRotationMatrix2D((cols/2,rows/2),rotate,1)
	dst = cv2.warpAffine(img,M,(cols,rows))
	return dst
}

function _getMinimumRotation(imgIn) {
	img = imgIn
	vals = []
	for i in range(35):
		img = rotateImgBAndW(img, 10)
		left, right = getCount(img)
		vals.append((abs(left-right),i*10))

	vals.sort(key=lambda tup: tup[0])  # sorts in place
	#print calcDiffSquared(135, 2, shape3)
	minRot = vals[0][1]
	
	temp1 = rotateImgBAndW(imgIn, minRot)
	left1, right1 = getCount(temp1)
	val1 = abs(left1-right1)

	temp2 = rotateImgBAndW(temp1, 180)
	left2, right2 = getCount(temp2)
	val2 = abs(left2-right2)

	if(val1<val2):
		return minRot
	else:
		return (minRot+180)%360
}

function getMinimumRotation(img) {
	print "img.shape"
	print img.shape
	resBAW = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
	minRot = getMinimumRotation(resBAW)
	return minRot
}

