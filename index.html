<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link rel="stylesheet" href="//cdn.jsdelivr.net/chartist.js/latest/chartist.min.css">
    <script src="//cdn.jsdelivr.net/chartist.js/latest/chartist.min.js"></script>

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">

    <title>Hello, world!</title>
</head>


<script>
    function zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) { r[i] = 0; } return r; }
    function zerosM(x,y) { return zeros(x).map(function() { return zeros(y); }); }

    function dot(a, b) {
        var ret = 0;
        for (var i = 0; i < a.length; ++i) {
            ret += a[i] * b[i];
        }
        return ret;
    }

    function norm2(a)  {
        return Math.sqrt(dot(a, a));
    }

    function scale(ret, value, c) {
        for (var i = 0; i < value.length; ++i) {
            ret[i] = value[i] * c;
        }
    }

    function weightedSum(ret, w1, v1, w2, v2) {
        for (var j = 0; j < ret.length; ++j) {
            ret[j] = w1 * v1[j] + w2 * v2[j];
        }
    }

    function gemv(output, A, x) {
        for (var i = 0; i < output.length; ++i) {
            output[i] = dot(A[i], x);
        }
    }


    /** minimizes a function using the downhill simplex method */
function nelderMead(f, x0, parameters) {
        parameters = parameters || {};

        var maxIterations = parameters.maxIterations || x0.length * 200,
            nonZeroDelta = parameters.nonZeroDelta || 1.05,
            zeroDelta = parameters.zeroDelta || 0.001,
            minErrorDelta = parameters.minErrorDelta || 1e-6,
            minTolerance = parameters.minErrorDelta || 1e-5,
            rho = (parameters.rho !== undefined) ? parameters.rho : 1,
            chi = (parameters.chi !== undefined) ? parameters.chi : 2,
            psi = (parameters.psi !== undefined) ? parameters.psi : -0.5,
            sigma = (parameters.sigma !== undefined) ? parameters.sigma : 0.5,
            maxDiff;

        // initialize simplex.
        var N = x0.length,
            simplex = new Array(N + 1);
        simplex[0] = x0;
        simplex[0].fx = f(x0);
        simplex[0].id = 0;
        for (var i = 0; i < N; ++i) {
            var point = x0.slice();
            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;
            simplex[i+1] = point;
            simplex[i+1].fx = f(point);
            simplex[i+1].id = i+1;
        }

        function updateSimplex(value) {
            for (var i = 0; i < value.length; i++) {
                simplex[N][i] = value[i];
            }
            simplex[N].fx = value.fx;
        }

        var sortOrder = function(a, b) { return a.fx - b.fx; };

        var centroid = x0.slice(),
            reflected = x0.slice(),
            contracted = x0.slice(),
            expanded = x0.slice();

        for (var iteration = 0; iteration < maxIterations; ++iteration) {
            simplex.sort(sortOrder);

            if (parameters.history) {
                // copy the simplex (since later iterations will mutate) and
                // sort it to have a consistent order between iterations
                var sortedSimplex = simplex.map(function (x) {
                    var state = x.slice();
                    state.fx = x.fx;
                    state.id = x.id;
                    return state;
                });
                sortedSimplex.sort(function(a,b) { return a.id - b.id; });

                parameters.history.push({x: simplex[0].slice(),
                    fx: simplex[0].fx,
                    simplex: sortedSimplex});
            }

            maxDiff = 0;
            for (i = 0; i < N; ++i) {
                maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
            }

            if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&
                (maxDiff < minTolerance)) {
                break;
            }

            // compute the centroid of all but the worst point in the simplex
            for (i = 0; i < N; ++i) {
                centroid[i] = 0;
                for (var j = 0; j < N; ++j) {
                    centroid[i] += simplex[j][i];
                }
                centroid[i] /= N;
            }

            // reflect the worst point past the centroid  and compute loss at reflected
            // point
            var worst = simplex[N];
            weightedSum(reflected, 1+rho, centroid, -rho, worst);
            reflected.fx = f(reflected);

            // if the reflected point is the best seen, then possibly expand
            if (reflected.fx < simplex[0].fx) {
                weightedSum(expanded, 1+chi, centroid, -chi, worst);
                expanded.fx = f(expanded);
                if (expanded.fx < reflected.fx) {
                    updateSimplex(expanded);
                }  else {
                    updateSimplex(reflected);
                }
            }

            // if the reflected point is worse than the second worst, we need to
            // contract
            else if (reflected.fx >= simplex[N-1].fx) {
                var shouldReduce = false;

                if (reflected.fx > worst.fx) {
                    // do an inside contraction
                    weightedSum(contracted, 1+psi, centroid, -psi, worst);
                    contracted.fx = f(contracted);
                    if (contracted.fx < worst.fx) {
                        updateSimplex(contracted);
                    } else {
                        shouldReduce = true;
                    }
                } else {
                    // do an outside contraction
                    weightedSum(contracted, 1-psi * rho, centroid, psi*rho, worst);
                    contracted.fx = f(contracted);
                    if (contracted.fx < reflected.fx) {
                        updateSimplex(contracted);
                    } else {
                        shouldReduce = true;
                    }
                }

                if (shouldReduce) {
                    // if we don't contract here, we're done
                    if (sigma >= 1) break;

                    // do a reduction
                    for (i = 1; i < simplex.length; ++i) {
                        weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);
                        simplex[i].fx = f(simplex[i]);
                    }
                }
            } else {
                updateSimplex(reflected);
            }
        }

        simplex.sort(sortOrder);
        return {fx : simplex[0].fx,
            x : simplex[0]};
    }


</script>




<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<canvas id="canvas"></canvas>

<script>

    var g_globalState = {
        canvasClickLocation: {x: 50, y: 50},

    };

    var g_p;
    var imgw_base = 100;
    var imgw = 100;
    var imgh = 100;
    var imgsrc = "image8-2.jpg";
    var g_img = new Image();
    g_img.src = imgsrc;





    function turnXIntoSqrtX(x) {
        return [Math.sqrt(x), 1 / (Math.sqrt(x))]
    }

    //a = [1,0,0], b = [[1],[0],[0]]
    //[1,0,0]*[[1],[0],[0]] = [1]
    function matrixMultiply(a, b) {
        var aNumRows = a.length, aNumCols = a[0].length,
            bNumRows = b.length, bNumCols = b[0].length,
            m = new Array(aNumRows);  // initialize array of rows
        for (var r = 0; r < aNumRows; ++r) {
            m[r] = new Array(bNumCols); // initialize the current row
            for (var c = 0; c < bNumCols; ++c) {
                m[r][c] = 0;             // initialize the current cell
                for (var i = 0; i < aNumCols; ++i) {
                    m[r][c] += a[r][i] * b[i][c];
                }
            }
        }
        return m;
    }



    function getPTheorm(xval, yval) {
        var sumOfSqr = (xval**2)+(yval**2);
        return Math.sqrt(sumOfSqr);
    }

    function getSquaredDistanceOfPoint(xval, yval) {
        var ret = getPTheorm(xval, yval)
        return ret*ret
    }

    function getTotalDiffSquaredOfPoints_matrix(points) {
        var total = 0;

        for (var i = 0; i < points.length; i++) {
            total += getSquaredDistanceOfPoint(points[i][0], points[i][1]);
        }

        return total;
    }

    function scaleInX_matrix(point, normX) {
        return [ point[0]*normX, point[1] ]
    }

    function rotatePoint_matrix(degrees, point) {
        rads = degrees  * Math.PI / 180.0; //convert to rads
        sinT = Math.sin(rads);
        cosT = Math.cos(rads);

        rotMat = [[cosT,sinT],[-sinT,cosT]];
        pointMat = [[point[0]], [point[1]]];

        return matrixMultiply(rotMat, pointMat);
    }

    function applyTransformToPoint_matrix(degrees, normX, point) {
        var ret = point;
        ret = rotatePoint_matrix(degrees, ret);

        ret = scaleInX_matrix(ret, normX);

        ret = rotatePoint_matrix(-degrees, ret);
        return ret
    }

    function applyTransformToAllPoints(tetha, normX, normY, points) {
        var ret = [];

        for (var i = 0; i < points.length; i++){

            newPoint = points[i];
            newPoint = applyTransformToPoint_matrix(tetha, normX, [newPoint[0], newPoint[1]]);
            newPoint = applyTransformToPoint_matrix(tetha+90, normY, [newPoint[0], newPoint[1]]);

            ret.push( [ newPoint[0][0], newPoint[1][0] ] )
        }
        return ret
    }

    function applyTransformToAllPointsNormd(tetha, normS, points) {
        var ret = turnXIntoSqrtX(normS);
        var normX = ret[0];
        var normY = ret[1];
        return applyTransformToAllPoints(tetha, normX, normY, points)
    }

    function loss(X) {
        var x = X[0], y = X[1];
        return Math.sin(y) * x  + Math.sin(x) * y  +  x * x +  y *y;
    }


    function getCenterPointOfPoly(arr) {
        var minX, maxX, minY, maxY;
        for(var i=0; i< arr.length; i++){
            minX = (arr[i][0] < minX || minX == null) ? arr[i][0] : minX;
            maxX = (arr[i][0] > maxX || maxX == null) ? arr[i][0] : maxX;
            minY = (arr[i][1] < minY || minY == null) ? arr[i][1] : minY;
            maxY = (arr[i][1] > maxY || maxY == null) ? arr[i][1] : maxY;
        }
        return [(minX + maxX) /2, (minY + maxY) /2];
    }

    function getTranslateMatrix(x, y) {
        return [
            [1, 0, x],
            [0, 1, y],
            [0, 0, 1]
        ];
    }

    function pointsToMatrixPoints(shape) {
        var outShape = [];
        for (var i = 0; i < shape[0].length; i++){
            var line = []
            for (var j = 0; j < shape.length; j++) {
                line.push(shape[j][i])
            }
            outShape.push(line);
        }
        var line = []
        for (var j = 0; j < shape.length; j++) {
            line.push(1)
        }
        outShape.push(line);

        return outShape;
    }

    function matrixPointsToPoints(shape) {
        var outShape = [];
        for (var i = 0; i < shape[0].length; i++){
            outShape.push( [ shape[0][i], shape[1][i] ] );
        }
        return outShape;
    }

    function prepForMinimise(shape) {
        var trans = getCenterPointOfPoly(shape);
        var transmat = getTranslateMatrix(-trans[0], -trans[1]);
        var points_1 = pointsToMatrixPoints(shape);
        var points_2 = matrixMultiply(transmat, points_1);
        return matrixPointsToPoints(points_2);
    }


    var g_global_shape = prepForMinimise([[0,0],[0,2],[2,2],[2,0]]);
    function ScaleAndAngleFuncObj () { /*...*/ }
    ScaleAndAngleFuncObj.prototype.scaleAndAngleFunc = function scaleAndAngleFuncObj (X) {
        var shape = g_global_shape;
        var angle = X[0];
        var scale = X[1];
        var result = calcDiffSquaredOfEveryPoint(shape, angle, scale);
        return result;
    };
    var fntomin = new ScaleAndAngleFuncObj();
    fntomin.selfshape = [[0,0],[0,1],[1,1],[1,0]];

    var solution = nelderMead(fntomin.scaleAndAngleFunc, [-3.5, 3.5]);
    console.log("solution is at " + solution.x);

    function scaleInDirection(shape, angle, scale) {
        return applyTransformToAllPointsNormd(angle, scale, shape)
    }

    function getAngleForOnePoint_matrix(point) {

        if(point[0] === 0 && point[1] >= 0) {
            return 270;
        } else if(point[0] === 0 && point[1] < 0) {
            return 90;
        }

        const atanVal = Math.atan(point[1]/point[0]);
        let degs = Math.abs(atanVal * 180.0/Math.PI);

        if (point[1] >= 0 && point[0] >= 0) {
            degs = 360 - degs;
        } else if (point[1] < 0 && point[0] >= 0) {
            //degs = degs;
        } else if (point[1] >= 0 && point[0] < 0) {
            degs += 180;
        } else if (point[1] < 0 && point[0] < 0) {
            degs = 180 - degs;
        }

        return degs
    }

    function getAngleBetweenTwoPoints_matrix(point1, point2) {
        return Math.abs(getAngleForOnePoint_matrix(point1) - getAngleForOnePoint_matrix(point2))
    }

    function getTotalDiffSquaredOfAngles_matrix(shape) {
        var retTotal = 0;
        for (var i = 0; i < shape.length; i++) {
            var allAnglesForPoint = [];
            for (var j = 0; j < shape.length; j++) {
                if (j === i)
                    continue;

                var angleBetweenPoints = getAngleBetweenTwoPoints_matrix(shape[i], shape[j])
                allAnglesForPoint.push(angleBetweenPoints);
            }
            var lowest = allAnglesForPoint[0];
            for (var k = 1; k < allAnglesForPoint.length; k++) {
                if (allAnglesForPoint[k] < lowest) {
                    lowest = allAnglesForPoint[k];
                }
            }
            retTotal += lowest*lowest//should we square this????
        }
        return retTotal
    }

    function calcDiffSquaredOfEveryPoint(shape, angle, scale) {
        if(scale < 0){
            scale = scale*-1
        }

        newShape = scaleInDirection(shape, angle, scale);
        totalDiff = getTotalDiffSquaredOfPoints_matrix(newShape);
        totalDiff += getTotalDiffSquaredOfAngles_matrix(newShape);
        return totalDiff
    }

    //now min the function

    function scaleAndAngleFunc(X) {
        var shape = this.selfshape;
        var angle = X[0];
        var scale = X[1];
        return calcDiffSquaredOfEveryPoint(shape, angle, scale);
    }

    function frange(x, y, jump) {
        while (x < y) {
            //yield x
            x += jump
        }
    }

    function getAllRotationAndScaleValuesForShape(shape) {
        var ret = []
        for (i in frange(0, 360, .1))
            for (j in frange(1,7, .1))
                val = calcDiffSquaredOfEveryPoint(shape, i, j)
        ret.append([val,['scaler',j],['angle', i]])

        return ret
    }

    function getAllRotationAndScaleValuesForShape_withOrder(shape) {
        vals = getAllRotationAndScaleValuesForShape(shape)
        //vals.sort(key=lambda tup: tup[0])  # sorts in place
        return vals
    }

    //########## public
    function getValuesToNormaliseScale1(shape) {
        finalShape = BSO.centerShapeUsingPoint(shape, (0,0))
        vals = getAllRotationAndScaleValuesForShape_withOrder(finalShape)
        //for i in range(10):
        //	print vals[i]
        //return the local minimum
        return (vals[0][2][1], vals[0][1][1])
    }

    function getValuesToNormaliseScale2(shape, inputRange) {
        shape = BSO.centerShapeUsingPoint(shape, (0,0))
        //bounds = [(low, high) for low, high in zip(inputRange[0], inputRange[1])]
        minimizer_kwargs = {"args": shape, "bounds": bounds}
        val = optimize.basinhopping(f, [1,1], minimizer_kwargs=minimizer_kwargs)
        scale = val['x'][1]
        if (scale < 0) {
            scale = scale*-1
        }
        return val['x'][0], scale
    }


    function getValuesToNormaliseScale(shape, inputRange) {
        shape = BSO.centerShapeUsingPoint(shape, (0,0))
        bounds = inputRange

        //global global_shape
        global_shape = shape
        val = optimize.differential_evolution(f, bounds)

        //#print val
        scale = val['x'][1]
        if (scale < 0) {
            scale = scale*-1
        }
        return val['x'][0], scale
    }

    function getValuesToNormaliseScaleNoInputRange(shape) {
        rangeInput = [(0.,359.0), (1.,8.)]
        return getValuesToNormaliseScale(shape, rangeInput)
    }

    /*
    ##################################################################

    ############# Rotation

    #################################################################
    */

    function getCount(img) {
        countLeft = 0
        countRight = 0
        height, width = img.shape
        for (i in range(0, height)) {
            for (j in range(0, width)) {
                if (j < (width/2)){
                    countLeft 	+= img[i,j]
                }
                else {
                    countRight 	+= img[i,j]
                }
            }
        }
        return countLeft, countRight
    }

    function rotateImgBAndW(img, rotate) {
        rows,cols = img.shape
        return _rotateImg(img, rotate, rows, cols)
    }

    function rotateImg(img, rotate) {
        rows,cols,c = img.shape
        return _rotateImg(img, rotate, rows, cols)
    }

    function _rotateImg(img, rotate, rows, cols) {
        M = cv2.getRotationMatrix2D((cols/2,rows/2),rotate,1)
        dst = cv2.warpAffine(img,M,(cols,rows))
        return dst
    }

    function _getMinimumRotation(imgIn) {
        img = imgIn
        vals = []
        for (i in range(35)){
            img = rotateImgBAndW(img, 10)
            left, right = getCount(img)
            vals.append((abs(left-right),i*10))
        }

        //vals.sort(key=lambda tup: tup[0])  # sorts in place
        //#print calcDiffSquared(135, 2, shape3)
        minRot = vals[0][1]

        temp1 = rotateImgBAndW(imgIn, minRot)
        left1, right1 = getCount(temp1)
        val1 = abs(left1-right1)

        temp2 = rotateImgBAndW(temp1, 180)
        left2, right2 = getCount(temp2)
        val2 = abs(left2-right2)

        if(val1<val2){
            return minRot
        }
        else{
            return (minRot+180)%360
        }
    }

    function getMinimumRotation(img) {
        print("img.shape")
        print(img.shape)
        resBAW = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        minRot = getMinimumRotation(resBAW)
        return minRot
    }



    function getCurrentPageMousePosition(e) {
        return {
            x: e.pageX,
            y: e.pageY
        };
    }


    function getCurrentCanvasMousePosition(e, canvasElem) {
        if (e.originalEvent.changedTouches != null && canvasElem != null) {
            var rect = canvasElem.getBoundingClientRect();
            return {
                x: e.originalEvent.changedTouches[0].clientX - rect.left,
                y: e.originalEvent.changedTouches[0].clientY - rect.top
            };
        } else if (e.clientX || e.clientX === 0 && canvasElem != null) {
            var rect = canvasElem.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        } else {
            console.log("Error: Invalid state");
        }
    }



    $("#" + "canvas").mousedown(function (e) {
        e.preventDefault();

        var canvasElem = $("#" + "canvas")[0];
        const pageMousePosition = getCurrentPageMousePosition(e);
        const canvasMousePosition = getCurrentCanvasMousePosition(e, canvasElem);
        console.log(pageMousePosition);
        console.log(canvasMousePosition);

        g_globalState.canvasClickLocation = {x: canvasMousePosition.x/imgw, y: canvasMousePosition.y/imgh};
        draw()
    });

    function tomdrawlin() {
        var c = document.getElementById("myCanvas");
        var ctx = c.getContext("2d");
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(300, 150);
        ctx.stroke();
    }


    function getPixels(image, width, height) {
        var canvas = document.getElementById('canvas');
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, width, height);
        return context.getImageData(0, 0, width, height).data;
    }

    function pointArrayToSpline() {

    }

    function toBlackAndWhite(imageData) {
        var output = []

        for (i = 0; i < imgh; i++) {
            var arr = []
            for (j = 0; j < imgw; j++) {
                var index = ( i * (imgw * 4) ) + (j * 4)
                var val = ((imageData[index] + imageData[index+1] + imageData[index+2])/3.0)
                arr.push(val)
            }
            output.push(arr)
        }
        return output
    }

    function main() {
        //g_p = toBlackAndWhite(getPixels())
        draw();
    }

    function plotPoints(inputArr, yval, xval, leftVal, rightVal){
        labels = [];
        zvals = []
        nulllist = [];
        nulllistr = [];
        nulllistl = [];
        var i,j;

        for (i = 0; i < inputArr[0].length; i++)
        {
            labels.push(i);
            zvals.push(inputArr[0][i].z)

            //nulllist.push( (i != xval)? null : inputArr[xval] );
            //nulllistr.push( (i != rightVal)? null : inputArr[rightVal] );
            //nulllistl.push( (i != leftVal)? null : inputArr[leftVal] );
        }
        for (j = 0; j < inputArr[1].length; j++) {
            labels.push(i+ j);
            zvals.push(inputArr[1][j].z)
        }
        console.log(xval);
        // Initialize a Line chart in the container with the ID chart1
        new Chartist.Line('#chart1', {
            labels: labels,
            series: [
                zvals
            //    nulllist,
            //    nulllistr,
            //    nulllistl
            ]
        });
    }

    function findRightPointOfAnchor(output) {
        var deltaTotal = 0;
        for (i = 0; i < output.length - 1; i++) {
            deltaTotal += Math.abs( output[i+1].z - output[i].z );
            if (deltaTotal > 200){
                return output[i];
            }
        }
    }

    function inner_bilinear_interp(q00, q10, q01, q11, x, y) {
        var un_x = 1.0 - x; var un_y = 1.0 - y;
        return (q00 * un_x * un_y + q10 * x * un_y + q01 * un_x * y + q11 * x * y);
    }

    function bilinearInterp(image, xVal, yVal) {
        var x1 = Math.floor(xVal);
        var x2 = Math.floor(xVal) + 1;
        var y1 = Math.floor(yVal);
        var y2 = Math.floor(yVal) + 1;
        return inner_bilinear_interp(image[y1][x1], image[y2][x1], image[y1][x2], image[y2][x2], xVal - x1, yVal - y1)
    }

    function getTanFromDegrees(degrees) {
        return Math.tan(degrees * Math.PI/180);
    }

    function getCosFromDegrees(degrees) {
        return Math.cos(degrees * Math.PI/180);
    }

    function getSinFromDegrees(degrees) {
        return Math.sin(degrees * Math.PI/180);
    }

    function getDirectionPointsWithjump(xval, yval, xjump, yjump) {
        var dx = xval;
        var dy = yval;
        var output = [];
        var count = 0;
        while(dx < imgw && dx > 0 && dy < imgh && dy > 0) {
            if (count > 10) {
                break;
            }
            output.push({x: dx, y: dy});
            count++;
            dx = dx + xjump;
            dy = dy + yjump;
        }
        return output;
    }

    function getDirectionPoints(xval, yval, rot) {
        var jumpH = 1;
        var cosval = getCosFromDegrees(rot);
        var sinval = getSinFromDegrees(rot);
        return [
            getDirectionPointsWithjump(xval + cosval, yval + sinval, cosval, sinval),
            getDirectionPointsWithjump(xval, yval, -cosval, -sinval)
            ]
    }
    
    function getZValues(image, xval, yval, rot) {
        var points = getDirectionPoints(xval, yval, rot);
        var rightvals = [];
        for (var i = 0; i < points[0].length; i++) {
            rightvals.push( {
                x: points[0][i].x,
                y: points[0][i].y,
                z: bilinearInterp(image, points[0][i].x, points[0][i].y)
            } );
        }
        var leftvals = [];
        for (var i = 0; i < points[1].length; i++) {
            leftvals.push( {
                x: points[1][i].x,
                y: points[1][i].y,
                z: bilinearInterp(image, points[1][i].x, points[1][i].y)
            } );
        }
        return [rightvals, leftvals]
    }

    function drawPoint(interactiveCanvasContext, point, colour) {
        interactiveCanvasContext.beginPath();
        interactiveCanvasContext.strokeStyle = colour;
        console.log(point.x + ":" + point.y)
        interactiveCanvasContext.rect(point.x, point.y, 3, 3);
        interactiveCanvasContext.closePath();
        interactiveCanvasContext.stroke();
    }

    function plotImagePoints(output, xval, yval, rightVal, leftVal) {

        plotPoints( output, yval, xval, leftVal, rightVal )
    }

    function getPixelsInDirection() {

    }

    function draw() {
        var c = document.getElementById("canvas");
        var ctx = c.getContext("2d");
        ctx.clearRect(0, 0, c.width, c.height)
        var d = new Date();
        var n = d.getTime();
        var delta =  Math.round(100*(( n % 3000)/3000) );
        //imgw = imgw_base + delta;
        g_p = toBlackAndWhite(getPixels(g_img, imgw, imgh));
        xval = g_globalState.canvasClickLocation.x*imgw
        yval = g_globalState.canvasClickLocation.y*imgh
        yval = Math.round(yval)
        xval = Math.round(xval)

        var rot = 10;
        var zvals = getZValues(g_p, xval, yval, rot);

        var rightVal = findRightPointOfAnchor(zvals[0]);
        var leftVal = findRightPointOfAnchor(zvals[0]);

        if (rightVal)
            drawPoint(ctx, rightVal, "red")
        if (leftVal)
            drawPoint(ctx, leftVal, "red")

        drawPoint(ctx, {x: xval, y: yval}, "blue")
        plotImagePoints(zvals, xval, yval, rightVal, leftVal)

    }

</script>
<style>
    .ct-chart {
        width: 600px;
        height: 400px;


    }
    .ct-series-b .ct-point{
        stroke: blue !important;
    }
</style>
<body>
<div class="ct-chart ct-golden-section" id="chart1" width="100"></div>


<script>

</script>

<h1>Hello, world!</h1>
<img src="image8-2.jpg" width="200" height="200" onload="main()"/>
<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>



</body>
</html>

